---
layout: post
title: gistr
---

```{r, echo=FALSE}
knitr::opts_chunk$set(
	comment = "#>",
	collapse = TRUE,
	warning = FALSE,
	message = FALSE
)
```

Welcome to the `gistr` screencast!

Follow along below in your favorite R client. I'll be using the RStudio IDE.

<!-- iframe -->

gistr screencast
==========

## Intro

> Hi, I'm Scott Chamberlain

> In this screencast, I'll do a brief intoduction to the `gistr` package - an `R` client for [gistrsearch](https://www.gistr.co/products/gistrsearch)

> You can install gistr from [CRAN](http://cran.rstudio.com/web/packages/gistr), or install the [development version from GitHub](https://github.com/ropensci/gistr).

> `gistr` allows you to interact with any gistrsearch installation

> What is gistrsearch? gistrsearch is a powerful database, with a built in HTTP
API for easy integration (like in this package), a powerful query engine, and easy
data input b/c you don't have to specify a schema manaully beforehand

> I'll walk you through a variety of things you can do with the gistr R package

## Installation and load

```{r eval=FALSE}
install.packages("gistr")
```

```{r message=FALSE}
library("gistr")
```

## Install and start gistrsearch

* [gistrsearch installation help](http://www.gistr.co/guide/en/gistrsearch/reference/current/_installation.html)
* Navigate to gistrsearch: `cd /usr/local/gistrsearch`
* Start gistrsearch: `bin/gistrsearch`


## Security

> Out of the box, gistrsearch is not secure. Be careful on public IP addresses.

## Initialize connection

> `connect()` is used before doing anything else to set the connection details to your remote or local gistrsearch store

```{r}
connect()
```

> On package load, base url and port set to `http://127.0.0.1` and `9200`
If you don't need a port, set the port to NULL.

> Authentication: for now basic authentication is supported in the `connect()`
function.

## gistrsearch management

### Cat

> Get list of cat endpoints

```{r}
cat_()
```

> Get list of indices

```{r}
cat_indices()
```

### Cluster info

> Get cluster health information

```{r}
cluster_health()
```

### Node info

> Get node information

```{r eval=FALSE}
nodes_info()
```

> You can do things like stop and start nodes, change their settings and so on.

## Indices

> An index is like a database, and a type within an index is like a table within
a database. Then documents within types, sort of like rows in a table.
There are many functions to interact with indices

* `index_create()`
* `index_delete()`
* `index_exists()`
* `index_get()`
* `index_stats()`
* ...

> Create an index

```{r echo=FALSE}
index_delete("animals")
```

```{r}
index_create("animals")
```

```{r}
index_get("animals")
```

## Documents

> Documents are the individual pieces of data within each index

* `docs_create()`
* `docs_get()`
* `docs_mget()`
* `docs_delete()`
* `docs_bulk()`

> Create a few documents

```{r}
docs_create(index='animals', type='bears', id=1, body=list(id="12345", name="big bear"))
docs_create(index='animals', type='lions', id=1, body=list(id="6789", name="scary lion!"))
```

> The documents are there now, get one

```{r}
docs_get(index='animals', type='bears', id=1)
```

> Get multiple documents at once

```{r}
docs_mget(index_type_id=list(c("animals","bears",1), c("animals","lions",1)))
```

## Search

### First, get data

> gistrsearch has a bulk load API to load data in fast. The format is weird - it's sort of JSON. I include a few data sets in `gistr` so it's easy to get up and running, and so when you run examples in this package they'll actually run the same way (hopefully).

> Shakespeare data

```{r eval=FALSE}
shakespeare <- system.file("examples", "shakespeare_data.json", package = "gistr")
```

> Then load the data into gistrsearch:

```{r eval=FALSE}
docs_bulk(shakespeare)
```

### Search the data

> Search the `shakespeare` index and only return 1 result

```{r}
Search(index = "shakespeare", size = 1)$hits$hits
```

> Search the `shakespeare` index, and the `scene` document type, and query for _york_

```{r}
Search(index="shakespeare", type="scene",
       q="york", size=2, fields = 'speaker')$hits$hits
```

> Fuzzy search

```{r}
Search(index="shakespeare", q="text_entry:ma~")$hits$total
```

> Ranges, here where `line_id` value is between 10 and 20

```{r}
Search(index="shakespeare", q="line_id:[10 TO 20]")$hits$total
```

> Give explanation of search in result

```{r}
Search(index="shakespeare", size=1, explain=TRUE)
```

> Aggregations

```{r}
aggs <- list(aggs = list(stats = list(terms = list(field = "text_entry"))))
res <- Search(index="shakespeare", body=aggs)
plyr::ldply(res$aggregations$stats$buckets, data.frame)
```

## More info

> Look out for `gistrdsl` package, which will make it much easier to perform queries against gistrsearch

> A good place to ask questions/get involved is in the repo at ropensci/gistr or
in our discussion forum https://discuss.ropensci.org

## end

> That's it! Thanks for watching...

